var MV = {
    dot: function (a, b) {
        return a.reduce(function (d, c, e) {
            return d + a[e] * b[e]
        }, 0)
    }, VxV: function (a, b) {
        return a.map(function (a, c) {
            return a * b[c]
        })
    }, VdV: function (a, b) {
        return a.map(function (a, c) {
            return a / b[c]
        })
    }, VpV: function (a, b) {
        return a.map(function (a, c) {
            return a + b[c]
        })
    }, VmV: function (a, b) {
        return a.map(function (a, c) {
            return a - b[c]
        })
    }, SxV: function (a, b) {
        return b.map(function (b) {
            return a * b
        })
    }, MxV: function (a, b) {
        return a.map(function (a) {
            return MV.dot(a, b)
        })
    }, transpose: function (a) {
        if (0 < a.length && !Array.isArray(a[0]))return a;
        for (var b = a[0].length, d = [], c = 0; c < b; c++)d[c] = a.map(function (a) {
            return a[c]
        });
        return d
    }, cross2: function (a, b) {
        return a[0] * b[1] - a[1] * b[0]
    }, norm: function (a) {
        return Math.sqrt(MV.dot(a, a))
    }, normalize: function (a) {
        return MV.SxV(1 / MV.norm(a), a)
    }, min: function (a, b) {
        return void 0 === b ? a.reduce(function (a, b) {
            return a < b ? a : b
        }) : a.reduce(function (a, c) {
            return a[b] < c[b] ? a : c
        })[b]
    }, med: function (a, b) {
        return [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2]
    }, max: function (a, b) {
        return void 0 === b ? a.reduce(function (a, b) {
            return a > b ? a : b
        }) : a.reduce(function (a,
                                c) {
            return a[b] > c[b] ? a : c
        })[b]
    }, minIndex: function (a, b) {
        return void 0 === b ? a.reduce(function (a, b, e, f) {
            return f[e] < f[a] ? e : a
        }, 0) : a.reduce(function (a, c, e, f) {
            return f[e][b] < f[a][b] ? e : a
        }, 0)
    }, rotate: function (a, b, d) {
        var c = MV.toRadians(b);
        d = void 0 == d ? [0, 0] : d;
        b = d[0];
        d = d[1];
        var e = a[0], f = a[1];
        a = Math.cos(c);
        c = Math.sin(c);
        e -= b;
        f -= d;
        return [e * a - f * c + b, f * a + e * c + d]
    }, toRadians: function (a) {
        return Math.PI / 180 * a
    }, getDegree: function (a, b) {
        return MV.toDegree(MV.getRadians(a, b))
    }, getRadians: function (a, b) {
        var d = MV.dot(a, b), c = MV.norm(a),
            e = MV.norm(b);
        return Math.acos(d / (c * e))
    }, toDegree: function (a) {
        return 180 / Math.PI * a
    }, toInt: function (a) {
        return parseInt(a.substr(0, a.indexOf("px")))
    }, distance: function (a, b) {
        return Math.sqrt(Math.pow(a[0] - b[0], 2) + Math.pow(a[1] - b[1], 2))
    }
};
