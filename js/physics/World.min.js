Array.prototype.indexOf || (Array.prototype.indexOf = function (v, x) {
    var l;
    if (null == this)throw new TypeError('"this" is null or not defined');
    var s = Object(this), d = s.length >>> 0;
    if (0 === d)return -1;
    l = +x || 0;
    Infinity === Math.abs(l) && (l = 0);
    if (l >= d)return -1;
    for (l = Math.max(0 <= l ? l : d - Math.abs(l), 0); l < d;) {
        if (l in s && s[l] === v)return l;
        l++
    }
    return -1
});
var World = function () {
    function v() {
        this.quadTree.clear();
        var d = this;
        this.removes.forEach(function (f) {
            f = d.bodies.indexOf(f);
            -1 != f && d.bodies.splice(f, 1)
        });
        this.removes = [];
        this.bodies.forEach(function (f, e, h) {
            f.index = e;
            var a = !0;
            if (f.dinamic) {
                var c = MV.VpV(f.center, MV.SxV(d.dt, f.vLin)), b = d.dt * f.vAng;
                f.center = c;
                f.shape.center = f.center;
                f.shape.theta += b;
                c = getAABB(f);
                AABBoverlap(c, d.quadTree.AABB, 0) || (h.splice(e, 1), a = !1)
            }
            a && d.quadTree.addBody(f)
        })
    }

    function x() {
        var d = getCollisionCandidates(this);
        computeFaceNormals(this.bodies,
            d);
        this.contacts = [];
        for (var f = d.length, e, h, a = 0; a < f; a++)if (e = d[a], h = this.bodies[e[0]], e = this.bodies[e[1]], h.dinamic || e.dinamic)h = getContactsFromBodyPair(h, e), this.contacts = this.contacts.concat(h)
    }

    function l() {
        for (var d = [], f = [], e = [], h = 0; h < this.joints.length; h++) {
            var a = this.joints[h];
            d[h] = [a.bodyB.mInv, a.bodyB.mInv].concat(a.bodyB.moiInv).concat([a.bodyA.mInv, a.bodyA.mInv]).concat(a.bodyA.moiInv);
            if ("vertex" == a.type)var c = a.bodyA.getVerticesInWorldCoords()[a.vertexA], b = a.bodyB.getVerticesInWorldCoords()[a.vertexB];
            else a.type = "center", c = a.bodyA.getVerticesInWorldCoords()[a.vertexA], b = a.bodyB.center;
            var r = a.bodyA.center, a = a.bodyB.center;
            e[h] = MV.SxV(2, MV.VmV(b, c).concat(MV.cross2(MV.VmV(c, b), MV.VmV(b, a))).concat(MV.VmV(c, b)).concat(MV.cross2(MV.VmV(b, c), MV.VmV(c, r))));
            c = MV.dot(MV.VmV(c, b), MV.VmV(c, b));
            f[h] = this.beta / this.dt * c
        }
        for (h = 0; h < this.nIterations; h++)for (c = 0; c < this.joints.length; c++) {
            var b = this.joints[c].bodyA, r = this.joints[c].bodyB, a = r.vLin.concat(r.vAng).concat(b.vLin).concat(b.vAng), l = MV.dot(e[c], MV.VxV(d[c],
                e[c]));
            1E-15 >= Math.abs(l) || (l = -(MV.dot(e[c], a) + f[c]) / l, a = MV.VpV(a, MV.VxV(d[c], MV.SxV(l, e[c]))), r.vLin = a.slice(0, 2), r.vAng = a[2], b.vLin = a.slice(3, 5), b.vAng = a[5])
        }
    }

    function s() {
        var d = [], f = [], e = [], h = [], a = [], c, b, l = this.contacts, w = l.length, n, m, g, k, q, p, s, t, u, v;
        b = this.beta;
        k = this.dt;
        var y = this.friction, x = this.nIterations;
        for (c = 0; c < w; c++)n = l[c], q = n.pA, p = n.pB, m = n.bodyA, g = n.bodyB, s = m.center, v = g.center, t = m.mInv, u = g.mInv, m = m.moiInv, g = g.moiInv, d[c] = [t, t, m, u, u, g], g = n.normal, m = MV.cross2(MV.VmV(q, s), g), t = MV.SxV(-1,
            g), n = -MV.cross2(MV.VmV(p, v), g), h[c] = [g[0], g[1], m, t[0], t[1], n], u = [-g[1], g[0]], m = MV.cross2(MV.VmV(q, s), u), t = MV.SxV(-1, u), n = -MV.cross2(MV.VmV(p, v), u), a[c] = [u[0], u[1], m, t[0], t[1], n], g = MV.dot(MV.VmV(q, p), g), f[c] = b / k * (0 > g ? g : 0) + 0, e[c] = 0;
        for (c = 0; c < x; c++)for (b = 0; b < w; b++)n = l[b], m = n.bodyA, g = n.bodyB, k = m.vLin, q = g.vLin, p = m.vAng, s = g.vAng, k = [k[0], k[1], p, q[0], q[1], s], p = -(MV.dot(h[b], k) + f[b]) / MV.dot(h[b], MV.VxV(d[b], h[b])), 0 > e[b] + p && (p = -e[b]), e[b] += p, k = MV.VpV(k, MV.VxV(d[b], MV.SxV(p, h[b]))), m.vLin = [k[0], k[1]], m.vAng =
            k[2], g.vLin = [k[3], k[4]], g.vAng = k[5], q = -MV.dot(a[b], k) / MV.dot(a[b], MV.VxV(d[b], a[b])), q > y * p ? q = y * p : q < -y * p && (q = -y * p), k = MV.VpV(k, MV.VxV(d[b], MV.SxV(q, a[b]))), m.vLin = [k[0], k[1]], m.vAng = k[2], g.vLin = [k[3], k[4]], g.vAng = k[5]
    }

    this.dt = 1 / 60;
    this.nIterations = 20;
    this.beta = .2;
    this.bodies = [];
    this.t = 0;
    this.friction = .5;
    this.contacts = [];
    this.gravity = 200;
    this.height = this.width = 5E3;
    this.joints = [];
    this.quadTree = new QuadTree([0, 0, this.width, this.height], 1);
    this.removes = [];
    this.step = function () {
        x.apply(this);
        var d = this.bodies,
            f = d.length, e, h, a, c, b, r, w, n, m, g, k = this.dt;
        for (w = 0; w < f; w++)if (e = d[w], h = e.mInv, 0 != h && e.dinamic)for (a = e.getRotationMatrix(), b = e.forces, c = b.length, g = e.forcePoints, n = 0; n < c; n++)m = g[n], r = b[n], e.vLin = MV.VpV(e.vLin, MV.SxV(k * h, r)), void 0 !== m && (r = MV.cross2(MV.MxV(a, e.shape.vertices[m]), r), e.vAng += k * e.moiInv * r);
        l.apply(this);
        s.apply(this);
        v.apply(this)
    };
    this.addBody = function (d) {
        d.dinamic && d.addForce([0, this.gravity * d.mass]);
        this.bodies.push(d);
        this.quadTree.addBody(d);
        d.index = this.bodies.length - 1
    };
    this.removeBody =
        function (d) {
            this.removes.push(d)
        };
    this.addJoint = function (d) {
        this.joints.push(d)
    };
    this.removeJoint = function (d) {
        for (var f = 0; f < this.joints.length; f++)if (this.joints[f] == d) {
            this.joints.splice(f, 1);
            break
        }
    }
};
